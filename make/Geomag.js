function cof2Obj(k) { k = k.split("\n"); var l = [], t, g, p, n, K; for (t in k) k.hasOwnProperty(t) && (g = k[t].replace(/^\s+|\s+$/g, "").split(/\s+/), 3 === g.length ? (p = parseFloat(g[0]), n = g[1], K = g[2]) : 6 === g.length && l.push({ n: parseInt(g[0], 10), m: parseInt(g[1], 10), gnm: parseFloat(g[2]), hnm: parseFloat(g[3]), dgnm: parseFloat(g[4]), dhnm: parseFloat(g[5]) })); return { epoch: p, model: n, modelDate: K, wmm: l } }
function Geomag(k) {
    function l(a) { a = a.split("\n"); var d = [], h, b, k, m, y; for (h in a) a.hasOwnProperty(h) && (b = a[h].replace(/^\s+|\s+$/g, "").split(/\s+/), 3 === b.length ? (k = parseFloat(b[0]), m = b[1], y = b[2]) : 6 === b.length && d.push({ n: parseInt(b[0], 10), m: parseInt(b[1], 10), gnm: parseFloat(b[2]), hnm: parseFloat(b[3]), dgnm: parseFloat(b[4]), dhnm: parseFloat(b[5]) })); g = { epoch: k, model: m, modelDate: y, wmm: d } } function t(P) {
        var d, h, b, k, m = [a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(),
        a.slice(), a.slice(), a.slice(), a.slice()], y = [a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice()], g = [a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice()], q = [a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice(), a.slice()]; b = P.wmm; for (d in b) b.hasOwnProperty(d) && b[d].m <= b[d].n && (m[b[d].m][b[d].n] =
            b[d].gnm, y[b[d].m][b[d].n] = b[d].dgnm, 0 !== b[d].m && (m[b[d].n][b[d].m - 1] = b[d].hnm, y[b[d].n][b[d].m - 1] = b[d].dhnm)); for (b = q[0][0] = 1; 12 >= b; b++)for (q[0][b] = q[0][b - 1] * (2 * b - 1) / b, h = 2, d = 0, k = b - d + 1; 0 < k; k--, d++)g[d][b] = ((b - 1) * (b - 1) - d * d) / ((2 * b - 1) * (2 * b - 3)), 0 < d && (h = (b - d + 1) * h / (b + d), q[d][b] = q[d - 1][b] * Math.sqrt(h), h = 1, m[b][d - 1] *= q[d][b], y[b][d - 1] *= q[d][b]), m[d][b] *= q[d][b], y[d][b] *= q[d][b]; g[1][1] = 0; D = { epoch: P.epoch, k: g, c: m, cd: y }
    } var g, p = 6378.137, n = 6356.7523142, K = 6371.2, v = p * p, z = n * n, O = v - z, M = v * v, H = z * z, Q = M - H, a = [0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0], D; this.setCof = function (a) { l(a); t(g) }; this.getWmm = function () { return g }; this.setUnnorm = function (a) { D = a }; this.getUnnorm = function () { return D }; this.getEpoch = function () { return D.epoch }; this.setEllipsoid = function (a) { p = a.a; n = a.b; K = 6371.2; v = p * p; z = n * n; O = v - z; M = v * v; H = z * z; Q = M - H }; this.getEllipsoid = function () { return { a: p, b: n } }; this.mag = this.calc = this.calculate = function (a, d, h, b) {
            function k(a) { return 180 / Math.PI * a } if (void 0 === D) throw Error("A World Magnetic Model has not been set."); if (void 0 ===
                a || void 0 === d) throw Error("Latitude and longitude are required arguments."); var m = D.epoch, g = D.k, l = D.c, q = D.cd, p = h / 3280.8399 || 0; b = function (a) { a = a || new Date; var b = a.getFullYear(), c = 864E5 * (365 + (0 === b % 400 || 0 === b % 4 && 0 < b % 100 ? 1 : 0)); return a.getFullYear() + (a.valueOf() - (new Date(b, 0)).valueOf()) / c }(b) - m; m = Math.PI / 180 * a; h = Math.PI / 180 * d; var n = Math.sin(h), I = Math.sin(m), A = Math.cos(h), c = Math.cos(m), w = I * I, G = c * c, u, E, t = h = m = 0, H = 0, L, N, e, S = [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], R = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], f = [0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0], F = [f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice()], B = f.slice(), C = f.slice(), J = f.slice(), r = [f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice()], f = [f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice(), f.slice()], x; B[0] = 0; B[1] = n; C[1] = A; F[0][0] = 0; C[0] = 1; J[0] = 1;
            r[0][0] = 1; u = Math.sqrt(v - O * w); E = p * u; A = I / Math.sqrt((E + v) / (E + z) * ((E + v) / (E + z)) * G + w); n = Math.sqrt(1 - A * A); u = Math.sqrt(p * p + 2 * E + (M - Q * w) / (u * u)); w = Math.sqrt(v * G + z * w); p = (p + w) / u; I = O * c * I / (u * w); for (c = 2; 12 >= c; c++)B[c] = B[1] * C[c - 1] + C[1] * B[c - 1], C[c] = C[1] * C[c - 1] - B[1] * B[c - 1]; w = K / u; G = w * w; for (e = 1; 12 >= e; e++)for (G *= w, c = 0, E = e + c + 1; 0 < E; E--, c++)e === c ? (r[c][e] = n * r[c - 1][e - 1], f[c][e] = n * f[c - 1][e - 1] + A * r[c - 1][e - 1]) : 1 === e && 0 === c ? (r[c][e] = A * r[c][e - 1], f[c][e] = A * f[c][e - 1] - n * r[c][e - 1]) : 1 < e && e !== c && (c > e - 2 && (r[c][e - 2] = 0), c > e - 2 && (f[c][e - 2] =
                0), r[c][e] = A * r[c][e - 1] - g[c][e] * r[c][e - 2], f[c][e] = A * f[c][e - 1] - n * r[c][e - 1] - g[c][e] * f[c][e - 2]), F[c][e] = l[c][e] + b * q[c][e], 0 !== c && (F[e][c - 1] = l[e][c - 1] + b * q[e][c - 1]), L = G * r[c][e], 0 === c ? (N = F[c][e] * C[c], u = F[c][e] * B[c]) : (N = F[c][e] * C[c] + F[e][c - 1] * B[c], u = F[c][e] * B[c] - F[e][c - 1] * C[c]), h -= G * N * f[c][e], t += R[c] * u * L, m += S[e] * N * L, 0 === n && 1 === c && (J[e] = 1 === e ? J[e - 1] : A * J[e - 1] - g[c][e] * J[e - 2], L = G * J[e], H += R[c] * u * L); g = -h * p - m * I; l = 0 === n ? H : t / n; q = h * I - m * p; b = Math.sqrt(g * g + l * l); m = Math.sqrt(b * b + q * q); h = k(Math.atan2(l, g)); t = k(Math.atan2(q,
                    b)); 55 <= Math.abs(a) && (0 < a && 0 <= d ? x = h - d : 0 < a && 0 > d ? x = h + Math.abs(d) : 0 > a && 0 <= d ? x = h + d : 0 > a && 0 > d && (x = h - Math.abs(d)), 180 < x ? x -= 360 : -180 > x && (x += 360)); return { dec: h, dip: t, ti: m, bh: b, bx: g, by: l, bz: q, lat: a, lon: d, gv: x }
        }; if (void 0 !== k) if ("string" === typeof k) l(k), t(g); else if ("object" === typeof k) this.setUnnorm(k); else throw Error("Invalid argument type");
}